from api.file_handler import FileHandler
from api.static_analyzer import StaticAnalyzer
from api.memory_analyzer import MemoryAnalyzer
from api.tcpdump_analyzer import TcpdumpAnalyzer
from api.voltality_analyzer import VoltalityAnalyzer
from api.report_generator import ReportGenerator
import signal
import os
import subprocess
import logging


class FileAnalyzer:
    def __init__(self, config):
        self.file_handler = FileHandler()
        self.config = config
        self.static_analyzer = StaticAnalyzer()
        self.memory_analyzer = MemoryAnalyzer()
        # self.voltality_analyzer = VoltalityAnalyzer()
        # self.report_generator = ReportGenerator()

    def analyze_file(self, file):
        self.file_handler.handle_file(file)
        static_report = self.static_analyzer.analyze_file(file.filename)
        memory_report = self.memory_analyzer.analyze_file(file.filename)
        #     volatility_report = self.voltality_analyzer.analyze_file(file.filename)
        report = self.report_generator.generate_report(
            file.filename,
            static_report,
            memory_report,
            #     volatility_report
        )

    def detonate_file(self, filename):
        # create a pcap file to capture network traffic
        logging.info("test")
        logging.debug("Starting to capture process logs")
        pcap_file = os.path.join(self.config['upload_dir'], 'network_traffic.pcap')
        logging.debug(pcap_file)
        subprocess.Popen(['tcpdump', '-i', 'any', '-w', pcap_file],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # execute the file
        p = subprocess.Popen([filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            outs, errs = p.communicate(timeout=self.config['timeout'])
        except subprocess.TimeoutExpired:
            # kill the process if it exceeds the timeout
            p.send_signal(signal.SIGINT)
            outs, errs = p.communicate()

        # stop the pcap capture
        subprocess.Popen(['pkill', 'tcpdump'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # determine if the file is infected
        if p.returncode == 0:
            return {'analysis': 'ok', 'result': {}}
        else:
            return {'analysis': 'infected', 'result': {'stdout': outs.decode('utf-8'), 'stderr': errs.decode('utf-8')}}
