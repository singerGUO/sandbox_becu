import uuid
from api.file_handler import FileHandler
from api.static_analyzer import StaticAnalyzer
from api.memory_analyzer import MemoryAnalyzer
from api.tcpdump_analyzer import TcpdumpAnalyzer
from api.voltality_analyzer import VoltalityAnalyzer
from api.report_generator import ReportGenerator
from api.uploader import upload_to_blob
import signal
import os
import subprocess
import logging
import time


class FileAnalyzer:
    def __init__(self, config):
        self.file_handler = FileHandler()
        self.config = config
        self.static_analyzer = StaticAnalyzer()
        self.memory_analyzer = MemoryAnalyzer()
        # self.voltality_analyzer = VoltalityAnalyzer()
        # self.report_generator = ReportGenerator()

    def analyze_file(self, file):
        self.file_handler.handle_file(file)
        static_report = self.static_analyzer.analyze_file(file.filename)
        memory_report = self.memory_analyzer.analyze_file(file.filename)
        #     volatility_report = self.voltality_analyzer.analyze_file(file.filename)
        report = self.report_generator.generate_report(
            file.filename,
            static_report,
            memory_report,
            #     volatility_report
        )

    def detonate_file(self, file_path):
        # create a pcap file to capture network traffic

        print("Starting to capture process logs")
        file_uuid = str(uuid.uuid4()) + ".pcap"
        pcap_file = os.path.join(self.config['upload_dir'], file_uuid)
        # probably use other virtual network interface
        subprocess.Popen(['tcpdump', '-w', pcap_file],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("start executing file")
        # execute the file
        p = subprocess.Popen([file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # wait for the process to finish
        time.sleep(3)
        try:
            print("process communication")
            outs, errs = p.communicate(timeout=self.config['timeout'])
        except subprocess.TimeoutExpired:
            print(" time out")
            # kill the process if it exceeds the timeout
            p.send_signal(signal.SIGINT)
            outs, errs = p.communicate()
        logging.debug("stop pcap file capture")
        # stop the pcap capture
        subprocess.Popen(['pkill', 'tcpdump'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        upload_to_blob(pcap_file)
        # determine if the file is infected
        if p.returncode == 0:
            return {'analysis': 'ok', 'result': {}}
        else:
            return {'analysis': 'infected', 'result': {'stdout': outs.decode('utf-8'), 'stderr': errs.decode('utf-8')}}
